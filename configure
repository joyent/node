#!/usr/bin/env python

import optparse
import os
import json
import subprocess
import sys

root_dir = os.path.dirname(__file__)
sys.path.insert(0, os.path.join(root_dir, 'deps', 'v8', 'tools'))
import utils # GuessArchitecture

# parse our options
parser = optparse.OptionParser()

parser.add_option("--debug",
    action="store_true",
    dest="debug",
    help="Also build debug build")

parser.add_option("--prefix",
    action="store",
    dest="prefix",
    help="Select the install prefix (defaults to /usr/local)")

parser.add_option("--without-ssl",
    action="store_true",
    dest="without_ssl",
    help="Build without SSL")

parser.add_option("--without-snapshot",
    action="store_true",
    dest="without_snapshot",
    help="Build without snapshotting V8 libraries. You might want to set"
         " this for cross-compiling. [Default: False]")

parser.add_option("--shared-v8",
    action="store_true",
    dest="shared_v8",
    help="Link to a shared V8 DLL instead of static linking")

parser.add_option("--shared-v8-includes",
    action="store",
    dest="shared_v8_includes",
    help="Directory containing V8 header files")

parser.add_option("--shared-v8-libpath",
    action="store",
    dest="shared_v8_libpath",
    help="A directory to search for the shared V8 DLL")

parser.add_option("--shared-v8-libname",
    action="store",
    dest="shared_v8_libname",
    help="Alternative lib name to link to (default: 'v8')")

parser.add_option("--openssl-includes",
    action="store",
    dest="openssl_includes",
    help="A directory to search for the OpenSSL includes")

parser.add_option("--openssl-libpath",
    action="store",
    dest="openssl_libpath",
    help="A directory to search for the OpenSSL libraries")

parser.add_option("--no-ssl2",
    action="store_true",
    dest="no_ssl2",
    help="Disable OpenSSL v2")

parser.add_option("--shared-cares",
    action="store_true",
    dest="shared_cares",
    help="Link to a shared C-Ares DLL instead of static linking")

parser.add_option("--shared-cares-includes",
    action="store",
    dest="shared_cares_includes",
    help="Directory containing C-Ares header files")

parser.add_option("--shared-cares-libpath",
    action="store",
    dest="shared_cares_libpath",
    help="A directory to search for the shared C-Ares DLL")

parser.add_option("--with-dtrace",
    action="store_true",
    dest="with_dtrace",
    help="Build with DTrace (experimental)")

# CHECKME does this still work with recent releases of V8?
parser.add_option("--gdb",
    action="store_true",
    dest="gdb",
    help="add gdb support")

parser.add_option("--dest-cpu",
    action="store",
    dest="dest_cpu",
    help="CPU architecture to build for. Valid values are: arm, ia32, x64")

parser.add_option("--dest-os",
    action="store",
    dest="dest_os",
    help="Operating system to build for. Valid values are: win, linux, freebsd, openbsd, solaris, mac")


(options, args) = parser.parse_args()


def pkg_config(pkg):
  cmd = os.popen('pkg-config --libs %s' % pkg, 'r')
  libs = cmd.readline().strip()
  ret = cmd.close()
  if (ret): return None

  cmd = os.popen('pkg-config --cflags %s' % pkg, 'r')
  cflags = cmd.readline().strip()
  ret = cmd.close()
  if (ret): return None

  return (libs, cflags)


def uname(switch):
  f = os.popen('uname %s' % switch)
  s = f.read().strip()
  f.close()
  return s


def parse_arch(arch, default):
  mapping = {
    'arm': {'arm'},
    'ia32': {'x86','ia32','i386'},
    'x64': {'x64','amd64','x86_64'},
    # TODO support MIPS when acceptable
  }
  
  if arch is not None:
    for (arch_normalised, arch_mapping) in mapping.items():
      for arch_optional in arch_mapping:
        if arch == arch_optional:
          return arch_normalised
  
  return default

def host_arch():
  """Host architecture. One of arm, ia32 or x64."""
  arch = uname('-p')

  if arch == 'unknown':
    arch = uname('-m')

  return parse_arch(arch, 'ia32')


def target_arch():
  return parse_arch(options.dest_cpu, host_arch())

def parse_os(os, default):
  mapping = {
    'linux': {'linux','cygwin'},
    'win': {'w'},
    'mac': {'mac','darwin','osx'},
    'solaris': {'solaris','sunos'},
    'freebsd': {'freebsd'},
    'openbsd': {'openbsd'},
  }
  
  if os is not None:
    for (os_normalised, os_mapping) in mapping.items():
      for os_optional in os_mapping:
        if os.startswith(os_optional):
          return os_normalised
  
  return default

def host_os():
  """Host operating system. One of win, linux, freebsd, openbsd, solaris, mac."""
  return parse_os(sys.platform, 'linux')

def target_os():
  """Target operating system to build node for. One of win, linux, freebsd, openbsd, solaris, mac."""
  return parse_os(options.dest_os, host_os())


def configure_node(o):
  # TODO add gdb
  o['variables']['node_debug'] = 'true' if options.debug else 'false'
  o['variables']['node_prefix'] = options.prefix if options.prefix else ''
  o['variables']['node_use_dtrace'] = 'true' if options.with_dtrace else 'false'
  o['variables']['host_arch'] = host_arch()
  o['variables']['target_arch'] = target_arch()
  o['variables']['host_os'] = host_os()
  o['variables']['OS'] = target_os()

  # TODO move to node.gyp
  if sys.platform == 'sunos5':
    o['variables']['visibility'] = '' # FIXME -fvisibility=hidden, should be a gcc check


def configure_libz(o):
  # TODO add -lz to libraries if linking libz as shared
  pass
  


def configure_v8(o):
  o['variables']['v8_use_snapshot'] = 'true' if not options.without_snapshot else 'false'
  o['variables']['node_shared_v8'] = 'true' if options.shared_v8 else 'false'

  # assume shared_v8 if one of these is set?
  if options.shared_v8_libpath:
    o['libraries'] += ['-L%s' % options.shared_v8_libpath]
  if options.shared_v8_libname:
    o['libraries'] += ['-l%s' % options.shared_v8_libname]
  if options.shared_v8_includes:
    o['include_dirs'] += [options.shared_v8_includes]

  # prevent v8 being built twice when its not needed
  if (target_arch()=="arm" and host_arch()!="arm") or (target_arch()=="x64" and host_arch()!="x64"):
    o['variables']['want_separate_host_toolset'] = 1
  else:
    o['variables']['want_separate_host_toolset'] = 0


def configure_cares(o):
  o['variables']['node_shared_cares'] = 'true' if options.shared_cares else 'false'

  # assume shared_cares if one of these is set?
  if options.shared_cares_libpath:
    o['libraries'] += ['-L%s' % options.shared_cares_libpath]
  if options.shared_cares_includes:
    o['include_dirs'] += [options.shared_cares_includes]


def configure_openssl(o):
  o['variables']['node_use_openssl'] = 'false' if options.without_ssl else 'true'

  if options.without_ssl:
    return

  if options.no_ssl2:
    o['defines'] += ['OPENSSL_NO_SSL2=1']

  out = pkg_config('openssl')
  (libs, cflags) = out if out else ('', '')

  if options.openssl_libpath:
    o['libraries'] += ['-L%s' % options.openssl_libpath, '-lssl', '-lcrypto']
  else:
    o['libraries'] += libs.split()

  if options.openssl_includes:
    o['include_dirs'] += [options.openssl_includes]
  else:
    o['cflags'] += cflags.split()

  if libs or cflags or options.openssl_libpath or options.openssl_includes:
    o['variables']['node_use_system_openssl'] = 'true'
  else:
    o['variables']['node_use_system_openssl'] = 'false'


print "configure options:", options

output = {
  'variables': {},
  'include_dirs': [],
  'libraries': [],
  'defines': [],
  'cflags': [],
}

configure_node(output)
configure_libz(output)
configure_v8(output)
configure_cares(output)
configure_openssl(output)

# variables should be a root level element,
# move everything else to target_defaults
variables = output['variables']
del output['variables']
output = {
  'variables': variables,
  'target_defaults': output
}

fn = os.path.join(root_dir, 'options.gypi')
print "creating ", fn

f = open(fn, 'w+')
f.write("# Do not edit. Generated by the configure script.\n")
json.dump(output, f, indent=2, skipkeys=True)
f.write("\n")
f.close()

subprocess.call(['tools/gyp_node','-f', 'make'])
